use yuho_core::ast::*;

/// Generate LaTeX legal document from Yuho program
pub fn to_latex(program: &Program) -> String {
    let mut gen = LatexGenerator::new();
    gen.generate(program)
}

/// Generate LaTeX with bibliography for precedent citations
pub fn to_latex_with_bibliography(program: &Program) -> String {
    let mut gen = LatexGenerator::new();
    gen.with_bibliography = true;
    gen.generate(program)
}

struct LatexGenerator {
    output: String,
    with_bibliography: bool,
    precedents: Vec<String>,
}

impl LatexGenerator {
    fn new() -> Self {
        Self {
            output: String::new(),
            with_bibliography: false,
            precedents: Vec::new(),
        }
    }

    fn generate(&mut self, program: &Program) -> String {
        self.output.push_str(
            r"\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{fancyvrb}
\usepackage{hyperref}

\title{Legal Specification}
\author{Generated by Yuho}
\date{\today}

\begin{document}
\maketitle

",
        );

        for item in &program.items {
            self.emit_item(item);
        }

        // Add bibliography if precedents exist
        if self.with_bibliography && !self.precedents.is_empty() {
            self.output.push_str("\n\\section*{Legal Precedents}\n\n");
            self.output.push_str("\\begin{enumerate}\n");
            for (idx, precedent) in self.precedents.iter().enumerate() {
                self.output.push_str(&format!(
                    "  \\item[{}] {}\n",
                    idx + 1,
                    self.escape_latex(precedent)
                ));
            }
            self.output.push_str("\\end{enumerate}\n\n");
        }

        self.output.push_str(
            r"\end{document}
",
        );

        std::mem::take(&mut self.output)
    }

    fn emit_item(&mut self, item: &Item) {
        match item {
            Item::Struct(s) => self.emit_struct(s),
            Item::Enum(e) => self.emit_enum(e),
            Item::Scope(s) => self.emit_scope(s),
            Item::Function(f) => self.emit_function(f),
            Item::Declaration(d) => self.emit_declaration(d),
            Item::TypeAlias(_) => {
                // Type aliases are compile-time only
            },
            Item::LegalTest(test) => self.emit_legal_test(test),
            Item::ConflictCheck(_) => {
                // Conflict checks are compile-time directives
            },
            Item::Principle(_) => {},
            Item::Proviso(_) => {
                // Proviso clauses are treated as compile-time directives
            },
            Item::Proviso(_) => { // For now, principles are not transpiled to this target
                 // Full Z3 verification support coming in future commits
            },
        }
    }

    fn emit_struct(&mut self, s: &StructDefinition) {
        self.output.push_str(&format!(
            r"\subsection*{{Definition: {}}}
\begin{{description}}
",
            self.escape_latex(&s.name)
        ));

        for field in &s.fields {
            // Check for precedent annotations
            let precedent_note = self.extract_precedent_annotation(&field.annotations);

            self.output.push_str(&format!(
                r"  \item[\texttt{{{}}}] {} (type: \texttt{{{}}}){}
",
                self.escape_latex(&field.name),
                self.type_description(&field.ty),
                self.type_to_latex(&field.ty),
                precedent_note
            ));
        }

        self.output.push_str(
            r"\end{description}

",
        );
    }

    fn extract_precedent_annotation(&mut self, annotations: &[Annotation]) -> String {
        for ann in annotations {
            if let Annotation::Precedent { citation } = ann {
                if self.with_bibliography {
                    let idx = self.precedents.len() + 1;
                    self.precedents.push(citation.clone());
                    return format!(" \\textit{{[See precedent {}]}}", idx);
                } else {
                    return format!(" \\textit{{({})}}", self.escape_latex(citation));
                }
            }
        }
        String::new()
    }

    fn emit_enum(&mut self, e: &EnumDefinition) {
        self.output.push_str(&format!(
            r"\subsection*{{Categories: {}}}
",
            self.escape_latex(&e.name)
        ));

        if e.mutually_exclusive {
            self.output.push_str(
                r"\textbf{MUTUALLY EXCLUSIVE}: Only one variant may be selected.

",
            );
        }

        self.output.push_str(
            r"The following categories are defined:
\begin{itemize}
",
        );

        for variant in &e.variants {
            self.output.push_str(&format!(
                r"  \item {}
",
                self.escape_latex(variant)
            ));
        }

        self.output.push_str(
            r"\end{itemize}

",
        );
    }

    fn emit_legal_test(&mut self, test: &LegalTestDefinition) {
        self.output.push_str(&format!(
            r"\subsection*{{Legal Test: {}}}
\textbf{{All}} of the following requirements must be satisfied:
\begin{{enumerate}}
",
            self.escape_latex(&test.name)
        ));

        for req in &test.requirements {
            self.output.push_str(&format!(
                r"  \item \texttt{{{}}} must be {}
",
                self.escape_latex(&req.name),
                self.type_description(&req.ty)
            ));
        }

        self.output.push_str(
            r"\end{enumerate}

",
        );
    }

    fn emit_scope(&mut self, s: &ScopeDefinition) {
        self.output.push_str(&format!(
            r"\section{{{}}}
",
            self.escape_latex(&s.name)
        ));

        for item in &s.items {
            self.emit_item(item);
        }
    }

    fn emit_function(&mut self, f: &FunctionDefinition) {
        let params: Vec<String> = f
            .params
            .iter()
            .map(|p| {
                format!(
                    "{}:{}",
                    self.escape_latex(&p.name),
                    self.type_to_latex(&p.ty)
                )
            })
            .collect();

        self.output.push_str(&format!(
            r"\subsection*{{Rule: {}}}
\begin{{Verbatim}}
func {}({}) -> {}
\end{{Verbatim}}

",
            self.escape_latex(&f.name),
            self.escape_latex(&f.name),
            params.join(", "),
            self.type_to_latex(&f.return_type)
        ));
    }

    fn emit_declaration(&mut self, d: &Declaration) {
        if let Expr::Match(m) = &d.value {
            self.emit_match_decision(d, m);
        } else {
            let expr = self.expr_to_latex(&d.value);
            self.output.push_str(&format!(
                r"\paragraph{{}} Let \texttt{{{}}} be defined as ${}$.

",
                self.escape_latex(&d.name),
                expr
            ));
        }
    }

    fn emit_match_decision(&mut self, d: &Declaration, m: &MatchExpr) {
        let scrutinee = self.expr_to_latex(&m.scrutinee);

        self.output.push_str(&format!(
            r"\subsection*{{Decision: {}}}
Given ${}$, the following conditions apply:
\begin{{enumerate}}
",
            self.escape_latex(&d.name),
            scrutinee
        ));

        for case in &m.cases {
            let condition = match &case.pattern {
                Pattern::Literal(lit) => format!("${}$", self.literal_to_latex(lit)),
                Pattern::Identifier(id) => format!("\\texttt{{{}}}", self.escape_latex(id)),
                Pattern::Wildcard => "Otherwise".to_string(),
                Pattern::Satisfies(test_name) => format!(
                    "all \\texttt{{{}}} requirements are satisfied",
                    self.escape_latex(test_name)
                ),
            };
            let consequence = self.expr_to_latex(&case.consequence);

            self.output.push_str(&format!(
                r"  \item If {}: then ${}$
",
                condition, consequence
            ));
        }

        self.output.push_str(
            r"\end{enumerate}

",
        );
    }

    fn type_to_latex(&self, ty: &Type) -> String {
        match ty {
            Type::Int => "int".to_string(),
            Type::Float => "float".to_string(),
            Type::Bool => "bool".to_string(),
            Type::String => "string".to_string(),
            Type::Money => "money".to_string(),
            Type::Date => "date".to_string(),
            Type::Duration => "duration".to_string(),
            Type::Percent => "percent".to_string(),
            Type::Pass => "pass".to_string(),
            Type::Named(name) => self.escape_latex(name),
            Type::Union(a, b) => format!("{} | {}", self.type_to_latex(a), self.type_to_latex(b)),

            // Dependent types (Phase 1)
            Type::BoundedInt { min, max } => format!("int[{},{}]", min, max),
            Type::NonEmpty(inner) => format!("{}+", self.type_to_latex(inner)),
            Type::ValidDate { .. } => "date".to_string(),
            Type::Positive(inner) => format!("{}+", self.type_to_latex(inner)),
            Type::Array(inner) => format!("{}[]", self.type_to_latex(inner)),
            Type::MoneyWithCurrency(currency) => format!("money<{}>", currency),
            Type::Citation {
                section,
                subsection,
                act,
            } => {
                format!("ยง{}.{} of {}", section, subsection, self.escape_latex(act))
            },
            Type::TemporalValue {
                inner,
                valid_from,
                valid_until,
            } => {
                let mut result = format!("{}[temporal", self.type_to_latex(inner));
                if let Some(from) = valid_from {
                    result.push_str(&format!(", from: {}", from));
                }
                if let Some(until) = valid_until {
                    result.push_str(&format!(", until: {}", until));
                }
                result.push(']');
                result
            },
            Type::TypeVariable(name) => name.clone(),
            Type::Generic { name, args } => {
                let args_str = args
                    .iter()
                    .map(|arg| self.type_to_latex(arg))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{}<{}>", name, args_str)
            },
        }
    }

    fn type_description(&self, ty: &Type) -> String {
        match ty {
            Type::Int => "an integer value".to_string(),
            Type::Float => "a decimal number".to_string(),
            Type::Bool => "a true/false value".to_string(),
            Type::String => "text".to_string(),
            Type::Money => "a monetary amount".to_string(),
            Type::Date => "a calendar date".to_string(),
            Type::Duration => "a time period".to_string(),
            Type::Percent => "a percentage".to_string(),
            Type::Pass => "no value".to_string(),
            Type::Named(name) => format!("a {}", name),
            Type::Union(_, _) => "one of multiple types".to_string(),

            // Dependent types (Phase 1)
            Type::BoundedInt { min, max } => format!("an integer between {} and {}", min, max),
            Type::NonEmpty(_) => "a non-empty collection".to_string(),
            Type::ValidDate { .. } => "a valid date".to_string(),
            Type::Positive(_) => "a positive number".to_string(),
            Type::Array(_) => "an array".to_string(),
            Type::MoneyWithCurrency(currency) => format!("a monetary amount in {}", currency),
            Type::Citation {
                section,
                subsection,
                act,
            } => {
                format!(
                    "a legal citation to section {}.{} of {}",
                    section, subsection, act
                )
            },
            Type::TemporalValue {
                inner,
                valid_from,
                valid_until,
            } => {
                let mut desc = format!("a time-bound {}", self.type_description(inner));
                if let Some(from) = valid_from {
                    desc.push_str(&format!(" (effective from {})", from));
                }
                if let Some(until) = valid_until {
                    desc.push_str(&format!(" (valid until {})", until));
                }
                desc
            },
            Type::TypeVariable(name) => format!("type {}", name),
            Type::Generic { name, args } => {
                let args_str = args
                    .iter()
                    .map(|arg| self.type_description(arg))
                    .collect::<Vec<_>>()
                    .join(" and ");
                format!("{} of {}", name, args_str)
            },
        }
    }

    fn expr_to_latex(&self, expr: &Expr) -> String {
        match expr {
            Expr::Literal(lit) => self.literal_to_latex(lit),
            Expr::Identifier(name) => format!("\\text{{{}}}", self.escape_latex(name)),
            Expr::Binary(l, op, r) => {
                let op_str = match op {
                    BinaryOp::Add => "+",
                    BinaryOp::Sub => "-",
                    BinaryOp::Mul => "\\times",
                    BinaryOp::Div => "\\div",
                    BinaryOp::Mod => "\\mod",
                    BinaryOp::Eq => "=",
                    BinaryOp::Neq => "\\neq",
                    BinaryOp::Lt => "<",
                    BinaryOp::Gt => ">",
                    BinaryOp::Lte => "\\leq",
                    BinaryOp::Gte => "\\geq",
                    BinaryOp::And => "\\land",
                    BinaryOp::Or => "\\lor",
                };
                format!(
                    "({} {} {})",
                    self.expr_to_latex(l),
                    op_str,
                    self.expr_to_latex(r)
                )
            },
            Expr::Unary(op, e) => {
                let op_str = match op {
                    UnaryOp::Not => "\\neg",
                    UnaryOp::Neg => "-",
                };
                format!("{}{}", op_str, self.expr_to_latex(e))
            },
            Expr::Call(name, args) => {
                let arg_strs: Vec<_> = args.iter().map(|a| self.expr_to_latex(a)).collect();
                format!(
                    "\\text{{{}}}({})",
                    self.escape_latex(name),
                    arg_strs.join(", ")
                )
            },
            Expr::FieldAccess(obj, field) => {
                format!(
                    "{}.\\text{{{}}}",
                    self.expr_to_latex(obj),
                    self.escape_latex(field)
                )
            },
            Expr::StructInit(init) => {
                format!("\\text{{new {}}}\\{{}}", self.escape_latex(&init.name))
            },
            Expr::Match(_) => "\\text{(match)}".to_string(),
            Expr::Forall { var, ty, body } => {
                format!(
                    "\\forall {}: {:?}, {}",
                    self.escape_latex(var),
                    ty,
                    self.expr_to_latex(body)
                )
            },
            Expr::Exists { var, ty, body } => {
                format!(
                    "\\exists {}: {:?}, {}",
                    self.escape_latex(var),
                    ty,
                    self.expr_to_latex(body)
                )
            },
        }
    }

    fn literal_to_latex(&self, lit: &Literal) -> String {
        match lit {
            Literal::Int(n) => n.to_string(),
            Literal::Float(n) => n.to_string(),
            Literal::Bool(b) => if *b { "\\top" } else { "\\bot" }.to_string(),
            Literal::String(s) => format!("\\text{{``{}''}}", self.escape_latex(s)),
            Literal::Money(n) => format!("\\${:.2}", n),
            Literal::Date(d) => format!("\\text{{{}}}", self.escape_latex(d)),
            Literal::Duration(d) => format!("\\text{{{}}}", self.escape_latex(d)),
            Literal::Percent(p) => format!("{}\\%", p),
            Literal::Pass => "\\varnothing".to_string(),
        }
    }

    fn escape_latex(&self, s: &str) -> String {
        s.replace('\\', "\\textbackslash{}")
            .replace('&', "\\&")
            .replace('%', "\\%")
            .replace('$', "\\$")
            .replace('#', "\\#")
            .replace('_', "\\_")
            .replace('{', "\\{")
            .replace('}', "\\}")
            .replace('~', "\\textasciitilde{}")
            .replace('^', "\\textasciicircum{}")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use yuho_core::parse;

    #[test]
    fn test_latex_struct() {
        let source = "struct Person { string name, int age, }";
        let program = parse(source).unwrap();
        let output = to_latex(&program);
        assert!(output.contains("Definition: Person"));
        assert!(output.contains("\\documentclass"));
    }

    #[test]
    fn test_latex_enum() {
        let source = "enum Verdict { Guilty, NotGuilty, }";
        let program = parse(source).unwrap();
        let output = to_latex(&program);
        assert!(output.contains("Categories: Verdict"));
        assert!(output.contains("Guilty"));
    }

    #[test]
    fn test_latex_match() {
        let source = r#"
            match guilty {
                case true := "liable"
                case _ := "not liable"
            }
        "#;
        let program = parse(source).unwrap();
        let output = to_latex(&program);
        assert!(output.contains("enumerate"));
    }
}
